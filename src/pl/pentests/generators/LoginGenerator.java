package pl.pentests.generators;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.StringTokenizer;
import org.apache.commons.cli.BasicParser;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import pl.pentests.generators.logingenerator.entity.Person;

/**
 *
 * @author MarcinG
 */
public class LoginGenerator {

    private static final String YES = "y";
    private static final String NO = "n";
    private static final String NAME = "NAME";
    private static final String SURNAME = "SURNAME";
    private static final String EMAIL = "EMAIL";
    private static final String NICKNAME = "NICKNAME";
    private static Scanner scan;
    private static final ArrayList<String> lines = new ArrayList<String>();
    private static String userType;

    private static final ArrayList<Person> entities = new ArrayList<Person>();

    private static final Options options = new Options();

    static {
        Option optHelp = new Option("h", "help", false, "print this message");
        options.addOption(optHelp);
        Option optInteractive = new Option("i", "interactive", false, "interactive mode can be used with inputfile");
        options.addOption(optInteractive);
        Option optInFile = OptionBuilder.withLongOpt("input-file").withArgName("file").hasArg().withDescription("input file").create("in");
        options.addOption(optInFile);
        Option optOutFile = OptionBuilder.withLongOpt("output-file").withArgName("file").hasArg().withDescription("output file. Default stdout").create("out");
        options.addOption(optOutFile);
        Option optDataLineDistinct = OptionBuilder.withLongOpt("dataline-contain").withArgName("string").hasArg().withDescription("only lines conatining that string will be used").create("d");
        options.addOption(optDataLineDistinct);
        Option optRemoveChar = OptionBuilder.withLongOpt("remove-char").withValueSeparator(' ').withArgName("string").hasArgs().withDescription("remove that chars from data lines (space separated)").create("r");
        options.addOption(optRemoveChar);
//        Option replaceChar = OptionBuilder.withLongOpt("replace-char").withArgName("string").hasArg().withDescription("can only be used with remove option. Removed string will be replaced with that.").create("p");
//        options.addOption(replaceChar);
        Option optLineData = OptionBuilder.withLongOpt("data-type").withValueSeparator(',').withArgName("string").hasArg().withDescription("determine data type in lines, separated with space. Each line can have data like: NAME, SURNAME, NICKNAME, EMAIL.\nf.e. line \"James Bond 007@mi6.uk\" got \"NAME SURNAME EMAIL\". Default: name surname email").create("t");
        options.addOption(optLineData);
        Option optQuietMode = OptionBuilder.withLongOpt("quiet-mode").withDescription("prints only result and errors when not interactive").create("q");
        options.addOption(optQuietMode);
    }

    private static boolean quietMode = false;
    private static File inFile;
    private static File outFile;
    private static String inFilename;
    private static String outFilename;
    private static String dataContain;
    private static String nonDataContain;
    private static String replaceWhat;
    private static String replaceWith;
    private static String[] dataType = {"name", "surname", "email"};
    private static String[] removeChars;

    private static boolean interactive = false;

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        scan = new Scanner(System.in);
        CommandLineParser parser = new BasicParser();
        CommandLine cmdLine = null;
        try {
            cmdLine = parser.parse(options, args);
        } catch (ParseException exp) {
            HelpFormatter formatter = new HelpFormatter();
            formatter.printHelp(100, "LoginGenerator.jar", null, options, null);
            return;
        }
        if (cmdLine.hasOption("h") || (!cmdLine.hasOption("i") && !cmdLine.hasOption("in"))) {
            HelpFormatter formatter = new HelpFormatter();
            formatter.printHelp(100, "LoginGenerator.jar", null, options, null);
            return;
        }
        interactive = cmdLine.hasOption("i");

        if (cmdLine.hasOption("in")) {
            inFilename = cmdLine.getOptionValue("in");
        }
        if (cmdLine.hasOption("out")) {
            outFilename = cmdLine.getOptionValue("out");
        }
        if (cmdLine.hasOption("d")) {
            dataContain = cmdLine.getOptionValue("d");
        }
        if (cmdLine.hasOption("r")) {
            removeChars = cmdLine.getOptionValues("r");
        }
        if (cmdLine.hasOption("t")) {
            dataType = cmdLine.getOptionValues("t");
            if (!checkDataTypes()) {
                System.out.println("[-] provided data types are not valid");
                return;
            }
        }

        if (interactive || (!interactive && (inFilename == null || inFilename.length() == 0))) {
            System.out.print("[+] filename to process:");
            inFilename = scan.nextLine();
        }

        quietMode = cmdLine.hasOption("q") && !interactive;
        if (getFile()) {
            if (interactive) {
                parseDataLines();
                System.out.println("[+] only data (and spaces) must be present in lines");
                System.out.print("[+] do you want delete some chars? (y/[N]) ");
                boolean more;
                do {
                    more = false;
                    userType = getYesNoDefaultNo();
                    if (YES.equals(userType)) {
                        printLinesQuestion();
                        System.out.print("[+] what can be deleted? ");
                        replaceWhat = scan.nextLine();
                        System.out.print("[+] what type instead that? (empty input will delete it)");
                        replaceWith = scan.nextLine();
                        ArrayList<String> tmpList = new ArrayList<String>();
                        for (int i = 0; i < lines.size(); i++) {
                            tmpList.add(lines.get(i).replaceAll(replaceWhat, replaceWith));
                        }
                        lines.clear();
                        lines.addAll(tmpList);
                        printLinesQuestion();
                        System.out.print("[+] do you want delete some chars? (y/[N]) ");
                        userType = getYesNoDefaultNo();
                        if (YES.equals(userType)) {
                            more = true;
                        }
                    }
                } while (more);
                System.out.println("[+] each line can have data like: NAME, SURNAME, NICKNAME, EMAIL");
                System.out.println("[+] f.e. line \"James Bond 007@mi6.uk\" got \"NAME SURNAME EMAIL\"");
                System.out.print("[+] does every line contain the same type of data? ([Y]/n) ");
                userType = getYesNoDefaultYes();
                if (NO.equals(userType)) {
                    System.out.println("Sorry not implemented yet....");
                    return;
                }
                System.out.print("[+] looking on example above, what types of data we have (space between)? ");
                userType = scan.nextLine();
                for (String l : lines) {
                    StringTokenizer personTokens = new StringTokenizer(l);
                    StringTokenizer typeTokens = new StringTokenizer(userType);
                    if (personTokens.countTokens() == typeTokens.countTokens()) {
                        Person newOne = new Person();
                        while (typeTokens.hasMoreTokens()) {
                            String pt = personTokens.nextToken();
                            String tt = typeTokens.nextToken();
                            if (NAME.equalsIgnoreCase(tt)) {
                                newOne.setName(pt);
                            } else if (SURNAME.equalsIgnoreCase(tt)) {
                                newOne.setSurname(pt);
                            } else if (EMAIL.equalsIgnoreCase(tt)) {
                                newOne.setEmail(pt);
                            } else if (NICKNAME.equalsIgnoreCase(tt)) {
                                newOne.setNickname(pt);
                            }
                        }
                        entities.add(newOne);
                    } else {
                        System.out.println("[-] line '" + l + "' doesn't fit...");
                    }
                }
            } else {
                parseNonInteractive();
                for (String l : lines) {
                    StringTokenizer personTokens = new StringTokenizer(l);
                    if (personTokens.countTokens() == dataType.length) {
                        Person newOne = new Person();
                        for (String tt : dataType) {
                            String pt = personTokens.nextToken();
                            if (NAME.equalsIgnoreCase(tt)) {
                                newOne.setName(pt);
                            } else if (SURNAME.equalsIgnoreCase(tt)) {
                                newOne.setSurname(pt);
                            } else if (EMAIL.equalsIgnoreCase(tt)) {
                                newOne.setEmail(pt);
                            } else if (NICKNAME.equalsIgnoreCase(tt)) {
                                newOne.setNickname(pt);
                            }
                        }
                        entities.add(newOne);
                    } else {
                        System.out.println("[-] line '" + l + "' doesn't fit...");
                    }
                }
            }
            if (!quietMode) {
                System.out.println("[+] parsing data...");
            }

            ArrayList<String> usernames = new ArrayList<String>();
            for (Person p : entities) {
                usernames.addAll(p.generateListOfUsernames());
            }
            if (!quietMode) {
                System.out.println("[+] successfully generated " + usernames.size() + " unique usernames");
            }
            if (interactive) {
                System.out.print("[+] provide filename for output (none for stdout): ");
                userType = scan.nextLine();
            } else {
                userType = outFilename;
            }

            File outFile = null;
            if (userType.trim().length() > 0) {
                outFile = new File(userType);
                if (outFile.exists()) {
                    System.out.println("[-] wrong file provided:" + outFile.getAbsolutePath());
                    if (outFile.exists()) {
                        System.out.println("[-] file already exists...");
                    }
                    return;
                }
            }
//            HashSet<String> usernames = new HashSet<String>();
            if (outFile == null) {
                if (!quietMode) {
                    System.out.println("[+] here's what i got:");
                }
                for (String u : usernames) {
                    System.out.println(u);
                }
            } else {
                FileWriter fw = new FileWriter(outFile);
                BufferedWriter bw = new BufferedWriter(fw);
                for (String u : usernames) {
                    bw.write(u);
                    bw.newLine();
                }
                bw.close();
                if (!quietMode) {
                    System.out.println("[+] usernames saved to file: " + outFile.getAbsolutePath());
                }
            }
            if (!quietMode) {
                System.out.println("[+] done! Bye!");
            }
        }
    }

    public static boolean getFile() throws FileNotFoundException, IOException {
        inFile = new File(inFilename);
        if (inFile.isFile() && inFile.exists() && inFile.canRead()) {
            userType = "";
            if (interactive) {
                System.out.print("[+] got file:" + inFile.getAbsolutePath() + ". Is that right? ([Y]/n) ");
                userType = getYesNoDefaultYes();
                if (NO.equals(userType)) {
                    System.out.println("[-] then bye!");
                    printUsage();
                    return false;
                }
                System.out.print("[+] want me to print it? (y/[N]) ");
                userType = getYesNoDefaultNo();
                if (YES.equals(userType)) {
                    System.out.println("");
                }
            }
            BufferedReader br = new BufferedReader(new FileReader(inFile));
            String line;
            while ((line = br.readLine()) != null) {
                if (line.trim().length() > 0) {
                    lines.add(line);
                }
                if (interactive && YES.equals(userType)) {
                    System.out.println(line);
                }
            }
            if (interactive && YES.equals(userType)) {
                System.out.println("");
            }
            return true;
        } else {
            if (!inFile.exists()) {
                System.err.println("[-] file:" + inFile.getAbsolutePath() + " doesn't exists");
            } else if (!inFile.isFile()) {
                System.err.println("[-] file:" + inFile.getAbsolutePath() + " isn't file");
            } else {
                System.err.println("[-] file:" + inFile.getAbsolutePath() + " is not readable");
            }
        }
        return false;
    }

    public static void parseNonInteractive() {
        if (dataContain != null && dataContain.trim().length() > 0) {
            removeLinesNotConatining();
        }
        if (removeChars != null && removeChars.length > 0) {
            for (String toRemove : removeChars) {
                ArrayList<String> tmpList = new ArrayList<String>();
                for (int i = 0; i < lines.size(); i++) {
                    tmpList.add(lines.get(i).replaceAll(toRemove, ""));
                }
                lines.clear();
                lines.addAll(tmpList);
            }
        }
    }

    public static void parseDataLines() {
        boolean moreEditting;
        do {
            moreEditting = false;
            System.out.print("[+] does every (non empty) line contain data? ([Y]/n) ");
            userType = getYesNoDefaultYes();
            if (NO.equals(userType)) {
                System.out.print("[+] do data lines have something in common? ([Y]/n) ");
                userType = getYesNoDefaultYes();
                if (YES.equals(userType)) {
                    do {
                        System.out.print("[+] and that is: ");
                        dataContain = scan.nextLine();
                    } while (dataContain.trim().length() == 0);
                    removeLinesNotConatining();
                } else {
                    System.out.print("[+] do non-data lines have something in common? ([Y]/n) ");
                    userType = getYesNoDefaultYes();
                    if (YES.equals(userType)) {
                        do {
                            System.out.print("[+] and that is: ");
                            nonDataContain = scan.nextLine();
                        } while (nonDataContain.trim().length() == 0);
                        removeLinesConatining();
                    } else {
                        System.out.print("[+] want to provide lines to delete by their number? ([Y]/n) ");
                        userType = getYesNoDefaultYes();
                        if (YES.equals(userType)) {
                            printLinesWithNumbers();
                            boolean keepDeleting;
                            do {
                                keepDeleting = false;
                                System.out.print("[+] type line numbers you want me to delete (separated by space): ");
                                userType = scan.nextLine();
                                if (userType.trim().length() > 0) {
                                    StringTokenizer st = new StringTokenizer(userType);
                                    ArrayList<String> toDel = new ArrayList<String>();
                                    while (st.hasMoreTokens()) {
                                        String type = st.nextToken();
                                        try {
                                            int number = Integer.parseInt(type);
                                            if (number > 0 && number <= lines.size()) {
                                                toDel.add(lines.get(number - 1));
                                            }
                                        } catch (NumberFormatException nfe) {
                                        }
                                    }
                                    lines.removeAll(toDel);
                                    System.out.println("[+] now you got this:");
                                    printLinesWithNumbers();
                                    System.out.print("[+] is that ok now? ([Y]/n) ");
                                    userType = getYesNoDefaultYes();
                                    if (NO.equals(userType)) {
                                        keepDeleting = true;
                                    }
                                } else {
                                    keepDeleting = true;
                                }
                            } while (keepDeleting);
                        } else {
                            System.out.print("[+] want me to iterate through lines? ([Y]/n) ");
                            userType = getYesNoDefaultYes();
                            if (NO.equals(userType)) {
                                System.out.println("[-] so repair file manually and come back :)");
                                return;
                            }
                            ArrayList<String> toDel = new ArrayList<String>();
                            for (String l : lines) {
                                System.out.println(l);
                                System.out.print("[+] keep that line? ([Y]/n) ");
                                userType = getYesNoDefaultYes();
                                if (NO.equals(userType)) {
                                    toDel.add(l);
                                }
                            }
                            lines.removeAll(toDel);
                        }
                    }
                }
            }
            printLinesQuestion();
            System.out.print("[+] can we move on to the next steps? ([Y]/n) ");
            userType = getYesNoDefaultYes();
            if (NO.equals(userType)) {
                moreEditting = true;
            }
        } while (moreEditting);
    }

    public static void removeLinesConatining() {
        ArrayList<String> toDel = new ArrayList<String>();
        for (String l : lines) {
            if (l.contains(nonDataContain)) {
                toDel.add(l);
            }
        }
        lines.removeAll(toDel);
    }

    public static void removeLinesNotConatining() {
        ArrayList<String> toDel = new ArrayList<String>();
        for (String l : lines) {
            if (!l.contains(dataContain)) {
                toDel.add(l);
            }
        }
        lines.removeAll(toDel);
    }

    public static void printLinesQuestion() {
        System.out.print("[+] print provided lines? ([Y]/n) ");
        userType = getYesNoDefaultYes();
        if (YES.equals(userType)) {
            printLinesWithoutNumbers();
        }
    }

    public static void printUsage() {
        System.out.println("Usage: ");
        System.out.println("generator [filename]");
    }

    

    private static boolean checkDataTypes() {
        if (dataType.length == 0) {
            return false;
        }
        for (String s : dataType) {
            if (!s.equalsIgnoreCase(NAME) && !s.equalsIgnoreCase(SURNAME)
                    && !s.equalsIgnoreCase(EMAIL) && !s.equalsIgnoreCase(NICKNAME)) {
                return false;
            }
        }
        return true;
    }

    public static String getYesNoDefaultYes() {
        return getYesNoFromUser(YES);
    }

    public static String getYesNoDefaultNo() {
        return getYesNoFromUser(NO);
    }
    
    public static String getYesNoFromUser(String defaultVal) {
        String retval = "";
        retval = scan.nextLine();
        while (retval.trim().length() > 0 && !(YES.equalsIgnoreCase(retval) || NO.equalsIgnoreCase(retval))) {
            if (YES.equals(defaultVal)) {
                System.out.print("[-] please type [Y]/n:");
            } else {
                System.out.print("[-] please type y/[N]:");
            }
            retval = scan.nextLine();
        }
        if (retval.length() == 0) {
            retval = defaultVal;
        }
        return retval.toLowerCase();
    }

    public static void printLinesWithNumbers() {
        printLines(true);
    }

    public static void printLinesWithoutNumbers() {
        printLines(false);
    }

    public static void printLines(boolean number) {
        System.out.println("");
        int i = 1;
        for (String l : lines) {
            System.out.println((number ? "" + i + ": " : "") + l);
            i++;
        }
        System.out.println("");
    }

}
